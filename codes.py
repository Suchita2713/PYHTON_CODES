# -*- coding: utf-8 -*-
"""codes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cwEFkNQxZLt0S-Ls7LL1hLe_YTwmVXmT
"""

def vowel_str(s):
  s=s.lower()
  print(s)
  c=0
  n=len(s)
  for i in range(len(s)):
    if(s[i]=='a' or s[i]=='e' or s[i]=='i' or s[i]=='o' or s[i]=='u'):
      c+=(n-i)
  return c



string="ACID"
print(vowel_str(string))

def vowel_str(s):
  s=s.lower()
  c=0
  for i in range(len(s)):
    if(s[i]=='a' or s[i]=='e' or s[i]=='i' or s[i]=='o' or s[i]=='u'):
      for j in range(i,len(s)):
        c+=1
  return c



string=input()
print(vowel_str(string))

def rotations(s,s1):
  s=sorted(s.lower())
  s1=sorted(s1.lower())
  if(len(s1)==len(s)) and (s==s1):
    return "YES"
  else:
    return "NO"
s="codeQuotient"
s1="Quotientcode"
print(rotations(s,s1))

def rotations(s,s1):
  s=list(s)
  s1=list(s1)
  for i in range(len(s)):
    s.append(s[0])
    s.pop(0)
    if s==s1:
      return "YES"
      break
  else:
    return "NO"
    
s="codeQuotient"
s1="Quotientcode"
print(rotations(s,s1))

def rotations(s,s1):
  s=s+s
  if s1 in s:
    return "YES"
  else:
    return "NO"
s="abcde"
s1="abced"
print(rotations(s,s1))

def non_repeat(s):
  d={}
  l=[]
  for i in s:
    if(s.count(i)==1):
      l.append(s.index(i))
  return min(l)
    
  print(d)
s="codequotientchamp"
print(non_repeat(s))

def non_repeat(s):
  d={}
  l=[]
  for i in s:
    if(s.count(i)==1):
      return s.index(i)
      break
    
  print(d)
s="codequotientchamp"
print(non_repeat(s))

def isOneBitCharacter(self, bits: List[int]) -> bool:
        flag=False
        for i in range(len(bits)):
            if i==len(bits)-1:
                flag=True
            if(bits[i]==1):
                i+=1
        return flag

def minimumMoves(grid, startX, startY, goalX, goalY):
    count_moves = 0
    visited = set()
    queue = deque([[startX, startY, count_moves]])
    moves = [[1, 0], [-1, 0], [0, 1], [0, -1]]
    
    while queue:
        x_pos, y_pos, c = queue.popleft()
        c += 1
        
        for xi, yi in moves:
            x, y = x_pos, y_pos
            while True:
                x, y = x + xi, y + yi
                if 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == '.':
                    if x == goalX and y == goalY:
                        return c
                    elif (x, y) not in visited:
                        visited.add((x, y))
                        queue.append([x, y, c])
                        
                else:
                    break
                
    return -1

https://www.hackerrank.com/challenges/castle-on-the-grid/problem

s="ATULYA"
s=s.lower()
for i in s:
  if i=='a'or i=='o' or i=="e" or i=='i' or i=='u':
    s=s.replace(i,'@')
print(s)

def sum_(l):
  i=0
  ln=len(l)
  flag=0
  if sum(l)==0:
    flag=1
    return True
  else:
    l.pop(0)
    sum_(l)
  return flag
l=[6,-2,3,-1]
print(sum_(l))

l=[-1,20,7,9,-6,2,4]
flag=0
l.sort(reverse=True)
print(l)
for i in range(len(l)):
  if(sum(l))==0:
    flag=1
    break
  else:
    l.pop(0)
print(flag)

n=int(input())
a=[]
for i in range(1,n+1):
  if(i%2!=0):
    if(i==1):
      p=1
    else:
      p=p*2
  else:
    if(i==2):
      q=1
    else:
      q=q*3
if(n%2!=0):
  print(p)
else:
  print(q)

x=12
n,m=3,5
s,i,j=0,1,1
while(n*i<=x):
    s+=n*i
    i+=1

while(m*j<=x):
    s+=m*j
    j+=1
print(s)

import math
x=12
n,m=3,5
s=x//n
d=x//m
s3=(s//2)*((2*n)+(s-1)*n)
s5=(d//2)*((2*m)+(d-1)*m)
g=(n//math.gcd(n,m))*m
s15=(x//g)*((2*g)+((x//g)-1)*g)
print(s3+s5-s15)

m=3
i=0
n=10
while(i<n):
  print(3+(i*3))
  i+=1

l=[3,2,1,2,3,1,1]
d={}
for i in l:
  if(i in d):
    d[i]+=1
  else:
    d[i]=1
for i,j in d.items():
  if(j%2!=0):
    print(i)

l=[3,5,7,5,3,7,7]
l=sorted(l)
a=0
for i in l:
  a=a^i
print(a)

n=25
s=bin(25)[2:]
s=str(s)
a=s.count('1')
print(a)

n=25
s=bin(25)[2:] 
c=0                                                     
while(n!=0):
  n=n & (n-1)
  c+=1
print(c)

l=[6,10,8,3,7]
l1=[8,7,6,3]
x1=x2=0
for i in l:
  x1=x1^i
for i in l1:
  x2=x2^i
print(x1^x2)

a="ACID"
c=0
a=a.lower()
for i in range (len(a)):
  if(a[i]=='a' or a[i]=='e' or a[i]=='i' or a[i]=='o' or a[i]=='u'): 
    c+=(len(a)-i)
print(c)

s="codeQuotient"
s1="Quotientcode"
s=s+s1
if(s1 in s):
  print(True)
else:
  print(False)

l=[3,2,1]
l1=sorted(l)
l1=str(l1)
print(l1)
if l1 in l:
  print(1)